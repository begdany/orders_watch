use axum::{                 // Из библиотеки Axum (Фреймворк для создания веб-приложений)
    Json,                   // Импортируем структуру Json (Применяется для сериализации структуры в JSON-формат)
    Router,                 // Импортируем структуру Router (Применяется для определения структуры веб-приложения (маршрут -> функция))
    routing::get            // Импортируем функцию get из модуля routing (Применяется для обработки GET-запросов)
};
use std::net::SocketAddr;   // Импортируем структуру SocketAddr из модуля net стандартной библиотеки (Применяется для задания адреса и порта сервера)
use std::env;               // Импортируем модуль env из стандартной библиотеки (Применяется для настройки отображения сообщений логирования)
use serde::Serialize;       // Импортируем трейт Serialize из библиотеки serde (Применяется для сериализации структуры в JSON-формат)

#[derive(Serialize)]    // Автоматическая генерация реализации трейта Serialize для структуры FavoriteItem
struct FavoriteItem {   // Определение структуры FavoriteItem, содержащей данные о товаре
    brand: String,      // Название бренда, поле строкового типа данных
    name: String,       // Название товара, поле строкового типа данных
    price: u32,         // Стоимость товара в рублях, поле типа беззнакового целого числа 32 бита (0 .. 4 294 967 295)
}

async fn get_favorite_item() -> Json<FavoriteItem> {    // Объявление асинхронной функции get_favorite_item, которая возвращает данные о товаре в виде JSON-объекта
    let favorite_item = FavoriteItem {                  // Создаем экземпляр структуры FavoriteItem и задаем значения полей
        brand: "Outleap".to_string(),                   // Преобразуем строковый литерал &str в тип String
        name: "RUDEWAY CRM2".to_string(),               // Преобразуем строковый литерал &str в тип String
        price: 93307,
    };
    log::info!("Получен GET-запрос к (/), выводим данные о товаре");    // Логируем GET-запрос к /
    Json(favorite_item)                                 // Сериализуем переменную favorite_item в JSON-объект
}

async fn hello_world() -> &'static str {    // Объявляем асинхронную функцию hello_world, которая передает ссылку на статическую строку
    log::info!("Получен GET-запрос к (/hello_world), выводим (Hello, World!)"); // Логируем GET-запрос к /hello_world
    "Hello, World!"
}

#[tokio::main]      // Макрос, предоставляемый библиотекой tokio, который позволяет сделать функцию main асинхронной
async fn main() {   // Объявляем асинхронную функции main
    
    // Для того, чтобы сообщения лога появлялись в консоли без ввода команды
    // (прим. для Power Shell: $env:RUST_LOG = "info"), осуществляем следующую проверку:
    if env::var("RUST_LOG").is_err() {      // Если переменная RUST_LOG не существует в окружении Rust
        env::set_var("RUST_LOG", "info");   // Устанавливаем ее значение в info
    }

    env_logger::init();                 // Инициализируем систему логирования env_logger

    log::info!("Запуск сервера...");    // Логируем запуск сервера

    let app = Router::new()             // Создаем новый экземпляр Router
        .route("/hello_world", get(hello_world))    // Добавляем маршрут /hello_world, который обрабатывает GET-запросы и вызывает функцию hello_world
        .route("/", get(get_favorite_item));        // Добавляем маршрут /, который обрабатывает GET-запросы и вызывает функцию get_favorite_item

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));        // Задаем адрес и порт для сервера: http://127.0.0.1:3000
    log::info!("Сервер доступен по ссылке: http://{}", addr);   // Логируем ссылку на сервер

    match axum::Server::bind(&addr)     // Создаем новый экземпляр сервера с заданным ранее адресом и портом, обрабатывая результат выполнения serve
        .serve(app.into_make_service()) // Обрабатываем входящие запросы в соответствии с определенной ранее структурой в app
        .await                          // Ожидаем завершения операции
    {
        Ok(()) => (),                   // Сервер успешно запущен
        Err(e) => log::error!("Ошибка при инициализации сервера: {}", e), // Логируем ошибку инициализации сервера
    }
}